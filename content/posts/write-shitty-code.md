---
title: 'Write Shitty Code - why you should and feel good about it'
slug: 'write-shitty-code'
summary: 'Why you should write MORE shitty code and feel good about it.'
colId: 60d0f077b69e2df6b324616c
id: 61dde0b3def972ccb1d8c38e
createdAt: 'Tue Jan 11 2022 19:55:31 GMT+0000 (Coordinated Universal Time)'
updatedAt: 'Wed Feb 23 2022 16:14:59 GMT+0000 (Coordinated Universal Time)'
publishedOn: 'Wed Feb 23 2022 16:18:06 GMT+0000 (Coordinated Universal Time)'
author: kam-lasater
category: Engineering
hidden: false
featured: true
public: Wed Jan 26 2022 00:00:00 GMT+0000 (Coordinated Universal Time)
image: https://uploads-ssl.webflow.com/60d0f077b69e2d8f2d246168/61e01ceaa92e5f6848495201_shitty-code-v2.png
thumbnail: https://uploads-ssl.webflow.com/60d0f077b69e2d8f2d246168/61e01ceaa92e5f6848495201_shitty-code-v2.png
---
I know how to write good code.

  

Usually it means spending more time now to make the code better for some future state of the world. This assumes that I know what the future will look like. In software we rarely know what the future holds.

  

> In software we rarely know what the future holds

‍

Uncertainty can be caused by:

*   Not knowing the technology
*   Not knowing the business
*   Not knowing the user
*   Not knowing the data size of the system
*   Not knowing the longevity of the code
*   Unknown-unknowns (see 2020 for more complete list of examples)

‍  

When I have uncertainty about the future, cycle time is most important. It allows me to capture value from my code by: learning as quickly as possible, minimizing impacts of bad or faulty code, as well as shortening my time to market.

  

Any friction hurts my cycle time. This decreases the rate I can turn uncertainty into certainty aka learning. My longest term value is created by learning as quickly as possible, since it is a multiplier for all future code I write or systems I design. Said another way: As "writing is re-writing
